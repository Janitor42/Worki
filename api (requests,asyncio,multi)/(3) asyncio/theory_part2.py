import random
import asyncio


            # 1
            # asyncio.gather()
            # Конкурентный запуск нескольких корутин правильно

# Сила asyncio в том, что этот модуль позволяет запускать множество корутин в конкурентном режиме.
# Эти корутины могут быть созданы в виде группы и сохранены, а потом их можно,
# все вместе, в одно и то же время, запустить.

# Реализовать такой сценарий работы можно, воспользовавшись функцией asyncio.gather().
# Функция asyncio.gather() - позволяет вызывающей стороне группировать объекты, допускающие ожидание.
# Эти объекты, после группировки, можно запустить в конкурентном режиме.
# (Эта функция пригодится и для группировки, и для выполнения множества корутин или задач:)

# выполнение коллекции объектов, допускающих ожидание
# results = await asyncio.gather(coro1(), asyncio.create_task(coro2()))
# Параметры функции
# asyncio.gather(*aws, return_exceptions=False)
# *aws - корутины, задачи или future-объекты для выполнения
# return_exceptions:
    # False (по умолчанию): первое исключение прерывает выполнение других задач
    # True: исключения возвращаются как обычные результаты

"""Пример"""
# import asyncio
#
# async def task1():
#     await asyncio.sleep(1)
#     return "Результат 1"
#
# async def task2():
#     await asyncio.sleep(2)
#     return "Результат 2"
#
# async def main():
#     results = await asyncio.gather(task1(), task2())
#     print(results)  # ['Результат 1', 'Результат 2']
#
# asyncio.run(main())



# Функцией asyncio.gather() можно воспользоваться в ситуации,
# когда есть возможность заранее создать множество задач или корутин,
# которые потом нужно одновременно запустить и,
# прежде чем продолжать работу, нужно дождаться завершения работы каждой из них.

# Объекты, допускающие ожидание, можно выполнить в конкурентном режиме.
# После того, как они возвратят результаты, которых ожидает основная программа — она сможет продолжить работу.
# gather() - позволяет рассматривать группу объектов, допускающих ожидание, как один такой объект.

# функции нельзя передать напрямую список объектов, допускающих ожидание!!!!!
# asyncio.gather([coro1(), coro2()])
# передать можно только в случае распаковки
# asyncio.gather(*[coro1(), coro2()])

# Функция gather() не является блокирующей.
# Она, вместо блокировки выполнения кода, возвращает объект asyncio.Future
# который представляет группу объектов, допускающих ожидание.
# group = asyncio.gather(coro1(), coro2())
# После того, как объект Future будет создан, его выполнение в цикле событий планируется автоматически.
# все обьекты в группе будут выполнены как только представиться возможность


"""Пример"""
# async def task_coro(value):
#     await asyncio.sleep(1)
#     print(value)
# async def main(): # корутина, используемая в роли точки входа в программу
#     print('main starting')
#     coros = []
#     for i in range(10):#     # создание множества корутин
#         coro = task_coro(i)
#         coros.append(coro)
#     await asyncio.gather(*coros)
#     print('main done')

# asyncio.run(main())

#(общее пояснение)
# При выполнении этого примера запускается корутина main(), которая является точкой входа в программу.
# Затем эта корутина создаёт список из 10 объектов корутин, используя механизм спискового включения.
# Этот список передаётся функции gather(), его, с помощью оператора «звёздочка», распаковывают, представляя в виде
# 10 отдельных значений.
# Корутина main() ожидает выполнения объекта Future, возвращённого после вызова функции gather().
# Выполнение программы приостанавливается, она ждёт завершения выполнения всех запланированных корутин.
# Корутины выполняются в тот момент, когда у них появляется такая возможность.
# Каждая из них выводит уникальное сообщение и, перед завершением работы, «засыпает».
# Только после того, как все корутины из группы завершатся, корутина main() возобновляет работу и выводит итоговое сообщение.
# Этот пример демонстрирует подготовку коллекции корутин и передачу их, в виде отдельных аргументов, функции gather().





                    # 2
                    # asyncio.wait()

# Ожидание выполнения некоего условия для коллекции задач
# asyncio.wait()
# Функция asyncio.wait() принимает коллекции объектов, допускающих ожидание. Обычно это — объекты Task

# Коллекция может быть представлена списком, словарём или множеством, которые содержат заранее созданные объекты задач.
# Создать их можно, например, пользуясь функцией asyncio.create_task() и механизмом спискового включения:
# tasks = [asyncio.create_task(task_coro(i)) for i in range(10)]

# Функция asyncio.wait() не завершит работу до тех пор,
# пока в применении к переданной ей коллекции задач не будет выполнено некое условие.
# По умолчанию это условие заключается в том, чтобы выполнение всех задач было бы завершено.

# Функция wait() возвращает кортеж, включающий в себя два множества.
# Первое множество содержит все объекты задач, соответствующие условию.
# Второе содержит все остальные объекты задач, то есть те, которые условию не соответствуют.
# Эти множества называют множеством завершённых (done) задач и множеством незавершённых (pending) задач:

# done, pending = await asyncio.wait(tasks)

# Указать то, как долго мы хотим ждать выполнения заданного условия, можно
# с помощью аргумента timeout,
# который содержит тайм-аут, выраженный в секундах.
# ожидание завершения всех задач с тайм-аутом

# done, pending = await asyncio.wait(tasks, timeout=3)


"""Пример с await, done, pending"""

# async def task_coro(arg): #корутина, которая будет выполняться в новой задаче
#     value = random.randint(1,1000)     # генерирование случайного значения в диапазоне между 0 и 1000
#     await asyncio.sleep(0)# при виде await  передает в event loop о том что эта фун-ция конкурентна
#     print(f'>task {arg} done with {value}')#     # вывод значения
#
#
# async def main():# главная корутина
#     tasks = [asyncio.create_task(task_coro(i)) for i in range(10)]    # создание нескольких задач
#     done, pending = await asyncio.wait(tasks)# ожидание завершения выполнения всех задач
#     print('All done',done,pending)    # вывод результатов
#
# asyncio.run(main())# запуск asyncio-программы


# При запуске этого примера сначала создаётся корутина main(), которая используется как точка входа в asyncio-программу.
# Затем эта корутина, пользуясь механизмом спискового включения, создаёт список из 10 задач.
# Каждой из этих задач передаётся уникальный аргумент от 0 до 9.
# Потом корутина main() приостанавливается и ожидает завершения выполнения всех задач.
# Задачи выполняются. Каждая из них генерирует случайное значение, потом мы читаем await и понимаем что эта задача конкурентна
# а после этого выводит сгенерированное значение в таком порядке, в каком успевает и может.
# После того, как все задачи завершатся, корутина main() возобновляет работу и выводит итоговое сообщение.
# В этом примере показано то, как функцию wait() можно использоваться для организации ожидания завершения коллекции задач.
# Это, вероятно, тот самый сценарий её использования, который встречается чаще всего.
# Обратите внимание на то, что результаты выполнения этого кода каждый раз будут разными.
# Это так из-за того, что в нём используется генератор случайных чисел.


                                    # 3
                                    # asyncio.wait_for()
                                    #Ожидание выполнения корутины с указанием лимита времени

#Если время истечёт до завершения задачи — она отменяется  и возбуждается исключение asyncio.TimeoutError..

# coroutine asyncio.wait_for(aw, timeout)
# aw - корутина или задача
# timeout - максимальное время ожидания в секундах (может быть None для отключения таймаута)

"""пример задачи с wait_for()"""

async def task_coro():  # Определение асинхронной функции (корутины)
    value = random.randint(1, 1000)  # Генерация случайного числа от 1 до 1000
    print(f'>task got {value}')  # Вывод сгенерированного значения
    await asyncio.sleep(1)  # Приостановка выполнения на 1 секунду (без блокировки event loop)+конкурентность
    print('>task done')  # Сообщение после завершения ожидания

async def main():  # Главная корутина (точка входа)
    task = task_coro()  # Создание корутины (но пока не запуск!)
    try:
        # Ожидание выполнения корутины с таймаутом 0.5 секунды
        await asyncio.wait_for(task, timeout=0.5)
    except asyncio.TimeoutError:  # Обработка превышения времени ожидания
        print('Gave up waiting, task canceled')  # Сообщение об отмене

asyncio.run(main())  # Запуск event loop и выполнение программы


                                    # 3.1
                                    #дополнениe

#Если нужно получить все результаты(несколько корутин) или ничего  в одно время
# async def main():
#     tasks = [task_coro(i) for i in range(3)]
#
#     try:
#         # Объединяем все задачи в одну с помощью gather() и ждём с таймаутом
#         results = await asyncio.wait_for(asyncio.gather(*tasks), timeout=0.5)
#         print("Все задачи завершены:", results)
#     except asyncio.TimeoutError:
#         print("Не все задачи завершились в срок!")
#         # Задачи внутри gather() будут автоматически отменены

# asyncio.run(main())



                                    #3.2
                                    #дополнение
# Если нужно гарантированно завершить все корутины по таймауту и какие то из них выполняться какие то нет+
#так же увидеть что сохранилось а что не собралось

# async def task_coro(arg):# Определение асинхронной функции (корутины) с параметром arg
#     print(f"Task {arg} started")  # Вывод сообщения о старте задачи
#     await asyncio.sleep(arg)  # Приостановка выполнения на 'arg' секунд (не блокирующая) +конкурентность
#     print(f"Task {arg} done")  # Вывод сообщения о завершении задачи
#     return arg  # Возврат результата (arg умноженный на 10)
#
#
# async def main():# Главная корутина (точка входа в программу)
#     tasks = []  # Создание пустого списка для хранения задач
#     for i in range(10):
#         tasks.append(task_coro(i))  # Добавление корутины в список (но пока не запуск!)
#
#
#
#     done, pending = await asyncio.wait(tasks, timeout=2.1)    # Ожидание выполнения задач с таймаутом 2.1 секунды
#     # done - завершенные задачи, pending - незавершенные
#
#
#     print(f"\nЗавершено: {len(done)} задач ")    # Вывод статистики по выполненным/невыполненным задачам
#     print(f"Не завершено: {len(pending)} задач")    # Вывод статистики по выполненным/невыполненным задачам
#
#
#     for task in pending:    # Отмена всех незавершенных задач
#         task.cancel()  # Отправка запроса на отмену каждой незавершенной задачи
#
#
#     results=[]
#     for task in done:
#         results.append(task.result())         # Сбор результатов выполненных задач
#     print(f"Результаты: {results}")  # Вывод полученных результатов
#
#
# asyncio.run(main())# Запуск event loop и выполнение программы
