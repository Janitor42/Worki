# Запуск блокирующих задач в asyncio-программах
                # asyncio.to_thread() и loop.run_in_executor()
# Блокирующая задача — это такая задача, которая останавливает выполнение инструкций текущего потока.
# Если в asyncio-программе запускается блокирующая задача —
# она останавливает весь цикл событий, не давая выполняться любым другим корутинам.

#блокировка приведет к остановке цикла событий, все корутины встанут.

# asyncio.to_thread() — это высокоуровневый API, который рассчитан на разработчиков приложений.
# Эта функция принимает имя функции, которую нужно вызвать в асинхронном режиме,
# а так же — аргументы, необходимые переданной ей функции.

#пример-
# В этом примере мы определим функцию, которая на несколько секунд блокирует вызывающую сторону.
# Затем мы асинхронно выполним эту функцию в пуле потоков asyncio, пользуясь функцией asyncio.to_thread().
# пример выполнения блокирующей задачи, зависящей от подсистемы ввода/вывода, в asyncio
import asyncio
import time

# блокирующая задача, зависящая от подсистемы ввода/вывода
# Эта функция была добавленав модуль asyncio в Python 3.9.
# Он примет вызов функции и выполнит его в новом потоке, отдельном от потока, выполняющего цикл событий asyncio.
# Он позволяет циклу событий asyncio обрабатывать вызов блокирующей функции как сопрограмму и выполнять ее асинхронно,
# используя параллелизм на основе потоков вместо параллелизма на основе сопрограмм.
# def blocking_task():
#     # вывод сообщения
#     print('Task starting')
#     # блокировка на некоторое время
#     time.sleep(2)
#     # вывод сообщения
#     print('Task done')
#
#
# # главная корутина
# async def main():
#     # вывод сообщения
#     print('Main running the blocking task')
#     # создание корутины для блокирующей задачи
#     coro = asyncio.to_thread(blocking_task)
#     # планирование задачи
#     task = asyncio.create_task(coro)
#     # вывод сообщения
#     print('Main doing other things')
#     # позволяем запланированной задаче запуститься
#     await asyncio.sleep(0)
#     # ожидание завершения задачи
#     await task
#
#
# # запуск asyncio-программы
# asyncio.run(main())



                            # Асинхронные итераторы
# Итерирование некоего объекта — это одна из базовых операций в Python.
# Итерировать можно списки, строки, а так же — разные другие объекты.

# Асинхронный итератор — это объект, который реализует методы aiter() и anext().

# Итератор: объект, представляющий поток данных. Повторяющиеся вызовы метода итератора next()
# (или его передача встроенной функции next()) возвращают последовательные элементы из потока.
# Когда в итераторе больше не остаётся данных, вместо возврата нового значения возбуждается исключение StopIteration.

# Асинхронный итератор можно обойти и используя конструкцию async for, которая автоматически вызывает anext()
# на каждой итерации и дожидается завершения работы полученного объекта, допускающего ожидание,
# чтобы получить возвращённое значение.


                        # цикл async for?
# Цикл async for используется для обхода асинхронных итераторов.
# Это — асинхронный вариант обычного цикла for.

# Внутренние механизмы цикла async for автоматически разрешают объекты, допускающие ожидание,
# или ждут результатов работы таких объектов, при необходимости планируя выполнение корутин.
#
# Так как речь идёт о разновидности цикла for — предполагается, хотя и не требуется, чтобы каждый объект,
# допускающий ожидание, обход которого осуществляется, вырабатывал бы возвращаемые значения.


# Цикл async for можно использовать в корутинах для обхода асинхронных итераторов.
# async for item in async_iterator:
#     print(item)

# Цикл async for правильнее будет воспринимать как асинхронный вариант цикла for.


                        # Создание асинхронного итератора
# it = AsyncIterator()
# получить объект, допускающий ожидание, выполнив один шаг итератора
# awaitable = anext(it)
# выполнить один шаг итератора и получить результат
# result = await awaitable
#или в 1 строчку
# result = await anext(it)
# обход асинхронного итератора
# async for result in AsyncIterator():
#     print(result)


                    #Асинхронные генераторы
# Асинхронный генератор — это корутина, которая использует выражение yield.
#
# В отличие от функции-генератора, корутина может планировать и ожидать выполнение других корутин и задач.
# определение асинхронного генератора
# async def async_generator():
#     for i in range(10)
#         yield i


                    # Асинхронные менеджеры контекста
# Менеджер контекста в Python — это сущность, которая даёт возможность пользоваться средой, напоминающей блок try-finally.
# Она, при этом, предусматривает применение единообразного интерфейса и удобного синтаксиса.
# Например, речь идёт об использовании выражения with.

# Менеджер контекста — это объект, который определяет контекст времени выполнения,
# который должен быть создан при выполнении команды with.
# Менеджер контекста обрабатывает вход в целевой контекст времени выполнения для выполнения блока кода,
# а так же выход из этого контекста.

# Это  менеджеры контекста, работа которых, при входе в них и выходе из них, может быть приостановлена.

# Конструкция async with предназначена для создания и использования асинхронных менеджеров контекста.

# async with AsyncContextManager() as manager:
#     # ...Это приведёт к автоматическому ожиданию завершения работы «входной» и «выходной» корутин, к приостановке, при необходимости, вызывающей корутины.
#

# Мы применим выражение async with и, в одной строке кода, создадим менеджер контекста и войдём в него.
# Это приведёт к автоматическому ожиданию завершения «входного» метода менеджера.
# Затем, во внутреннем блоке кода, мы можем воспользоваться менеджером. В данном случае мы просто выводим сообщение.
# Выход из внутреннего блока кода приводит к автоматическому запуску ожидания завершения «выходного» метода менеджера контекста.
# Если сравнить этот пример с предыдущим подобным примером — можно заметить — как много всего автоматически выполняется конструкцией async with.
