import asyncio


#Для начала поговорим о Корутинах, т.к. это понимание лежит в основе асинхронного программирования:

                    #1
                    #Немного о Корутинах
# Корутина (coroutine, сопрограмма) — это функция, выполнение которой может быть приостановлено и возобновлено.
# Подпрограмму можно запустить, её работа начнётся в одном месте и завершится в другом.
# А корутину можно запустить, потом — приостановить, потом — возобновить.
# Приостанавливать и возобновлять выполнение корутины можно много раз — до того момента,
# пока её работа не будет, в итоге, завершена.

# Корутина — это метод, который можно приостановить,
# когда у нас имеется задача,
# выполнение которой может занять много времени.
# Потом, когда эта задача будет завершена, метод можно возобновить.

# В Python 3.5. была реализована встроенная поддержка корутин и асинхронного программирования,
# тогда в язык были добавлены ключевые слова async и await.




                    #2
                    #Программы, подпрограммы, сопрограммы
# Программа (routine) и подпрограмма (subroutine) — это понятия,
# которые в современном программировании часто используют для обозначения одних и тех же сущностей.

# Программа — это отдельный модуль, содержащий набор выражений, которому назначено имя.
# Она может принимать аргументы и возвращать значения.

# Подпрограмма: модуль с набором инструкций, который может быть выполнен по запросу.
# Обычно ей назначается имя, она способна принимать аргументы и возвращать значения.
# Подпрограммы ещё называют функциями.
# Подпрограмма запускается, выполняет содержащиеся в ней выражения и каким-то образом завершает работу,
# возвращая управление в место своего вызова. Обычно подпрограммы вызываются другими подпрограммами.

# А корутина, или сопрограмма — это расширенный вариант подпрограммы.
# То есть — подпрограммы можно считать особым типом корутин.
# И те и другие — это отдельные именованные модули, содержащие выражения.
# И те и другие могут принимать аргументы, а могут и не принимать.
# И те и другие могут возвращать значения или их не возвращать.

# Главное их различие заключается в том=====================>>>>>>>
# что корутины могут самостоятельно приостанавливать и возобновлять своё выполнение много раз
# до возврата значения и выхода из них.



                    #3
                    #Принцип работы, про wait
# Когда корутина вызывает другую корутину — она должна приостановить собственное выполнение
# и позволить другой корутине возобновить свою работу после того, как работа другой корутины завершится.
#Приостановка корутины может, кроме того, позволить выполниться любому количеству других корутин.

# Корутина может приостанавливать работу или передавать управление другой корутине,
# используя выражение await.
# После завершения работы вызванной корутины вызвавшая её корутина продолжит работу с того места,
# где была приостановлена.


                        # 4
                        # Как запустить корутину из Python-кода
# Корутины можно определять и создавать в обычном Python-коде, но запускать их можно только в цикле событий.
# Цикл событий, выполняющий корутины, организует работу кооперативной многозадачности, применяемой корутинами.
# Код объекта корутины может выполняться лишь тогда, когда работает цикл событий.

# Типичный способ запуска цикла событий для корутин заключается в использовании функции
# asyncio.run().
# Эта функция принимает одну корутину и возвращает значение корутины.
# Предоставленная ей корутина может быть использована как точка входа в программу, основанную на корутинах.

"""Пример:"""
# async def custom_coro():
#     await asyncio.sleep(1)

# async def main():
#     await custom_coro()

# asyncio.run(main())

                    #5
                    # объект asyncio.Task()
# Python есть особый объект, представляющий задачу. Это — объект asyncio.Task

# Корутину можно обернуть в объект asyncio.Task и выполнить независимо —
# в противовес её выполнению напрямую, внутри другой корутины.
# Объект Task даёт средства для асинхронного выполнения корутин.

# Обычно, если мы просто вызываем корутину внутри другой корутины с await,
# выполнение родительской корутины приостанавливается до тех пор, пока вызванная корутина не завершится.

"""Пример корутина внутри корутины с await:"""
# async def child():
#     print("Child start")
#     await asyncio.sleep(1)
#     print("Child end")
#
# async def parent():
#     print("Parent start")
#     await child()  # Parent приостанавливается здесь
#     print("Parent end")  # Этот код выполнится только после child()
#
# asyncio.run(parent())

"""Пример обернутая в Task корутина которая выполняется независимо"""
# async def child():
#     print("Child start")
#     await asyncio.sleep(1) #Специальная приостановка не блокирующая
#     print("Child end")
# async def parent():
#     print("Parent start")
#     task = asyncio.create_task(child())  # Создаём Task
#     # Parent продолжает выполняться, не дожидаясь завершения child()
#     await asyncio.sleep(0.5)  #Специальная приостановка не блокирующая
#     print("Parent end")
#     await task  # Теперь ждём завершения child()
#
# asyncio.run(parent())


# Неблокирующее поведение
# Ключевое отличие от обычного вызова корутины:
# С await child(): родительская корутина блокируется до завершения child().

# С asyncio.create_task(child()): родительская корутина продолжает выполняться сразу после создания задачи.


"""Доп пример с 2 задачами """
# async def worker(name, delay):
#     print(f"{name} started")
#     await asyncio.sleep(delay)
#     print(f"{name} finished")
#
# async def main():
#     # Создаём две задачи, которые будут выполняться конкурентно
#     task1 = asyncio.create_task(worker("Task 1", 2))
#     task2 = asyncio.create_task(worker("Task 2", 1))
#
#     # main продолжает выполняться, пока задачи работают
#     print("Main is doing other work")
#
#     # Ждём завершения обеих задач
#     await task1
#     await task2
#
# asyncio.run(main())


# Это позволяет обёрнутой корутине выполняться в фоновом режиме.
# Вызывающая корутина может продолжить выполнять инструкции вместо того,
# чтобы ожидать возврата управления от другой корутины.

# Объект Task не может существовать сам по себе. В него обязательно должна быть обёрнута корутина.

# Цена запуска корутины — это цена вызова функции.
# После того, как корутина активируется, она использует меньше 1 Кб памяти до тех пор, пока не отработает.




                                # 6
                                # Цикл событий asyncio
# Цикл событий — это сердце программ, основанных на asyncio.
# Цикл событий — это среда для выполнения корутин в одном потоке.
# Он отвечает за решение множества задач. Вот некоторые из них:
# Выполнение корутин.
# Выполнение коллбэков.
# Выполнение сетевых операций ввода/вывода.#
# Выполнение подпроцессов.

# Цикл событий, как видно из его названия, это — цикл.
# Он управляет списком задач (корутин) и стремится продвинуть выполнение каждой из них
# в определённой последовательности на каждой своей итерации.
# Он, кроме того, выполняет и другие задачи — наподобие выполнения коллбэков и обработки операций ввода/вывода.

# Запуск цикла событий и получение ссылки на его объект
# Обычно в asyncio-приложениях ссылки на объекты циклов событий получают, вызывая функцию asyncio.run().
# Эта функция всегда создаёт новый цикл событий и в конце завершает его работу.
# Её следует использовать как основную точку входа для asyncio-программ,
# в идеале её нужно вызывать в программах лишь один раз.
# Эта функция принимает корутину и выполняет её до завершения её работы.
# Обычно этой функции передают главную корутину, с которой начинается выполнение программы.
#
# Существуют и низкоуровневые функции для создания цикла событий и для работы с ним.
# Функция asyncio.new_event_loop() создаёт новый цикл событий и возвращает ссылку на него.
# Создаёт и возвращает новый объект цикла событий.

# пример:
# # создаём новый цикл событий asyncio и обеспечиваем доступ к нему
# loop = asyncio.new_event_loop()
# # сообщаем стандартные сведения о цикле
# print(loop)

# Если цикл событий asyncio уже выполняется —
# доступ к нему можно получить посредством функции asyncio.get_running_loop().

# asyncio.get_running_loop().
# Возвращает выполняющийся цикл событий в текущем потоке ОС.
# Если в потоке нет цикла событий — выдаётся ошибка RuntimeError.
# Эта функция может быть вызвана только из корутины или из коллбэка.


# Зачем может понадобиться доступ к циклу событий
# Зачем нам обращаться к циклу событий за пределами asyncio-программы?
# Например:
#
# Для мониторинга хода выполнения задач.
# Для выдачи и получения результатов работы задач.
# Для запуска одноразовых задач.



                            # 7
                            # asyncio-задачи
# Объекты Task (задачи) в asyncio-программах можно создавать из корутин.
# Задачи предоставляют инструменты, предназначенные для независимого планирования и выполнения корутин.
# Цикл событий asyncio управляет задачами.
# Получается, что все корутины в цикле событий становятся задачами, работа с ними тоже ведётся как с задачами.

# Task — это объект, который отвечает за планирование выполнения asyncio-корутин и за их независимый запуск.
# Задача — это объект, который отвечает за управление корутинами и за их независимый запуск.
# Задачи создают из корутин. Для создания задачи нужен объект корутины.
# Задача оборачивает корутину, планирует её выполнение и даёт средства для взаимодействия с ней.

# Задачи выполняются независимо друг от друга.
# Это значит, что их выполнение планируется в цикле событий asyncio,
# и что они выполняются независимо от того, что ещё происходит в создавшей их корутине.
# Это отличается от прямого выполнения корутины, когда вызывающая сторона должна дождаться её завершения.

# Так как Task — это объект, допускающий ожидание, получается,
# что корутина может подождать завершения задачи с использованием выражения
# await.
# Например: подождать завершения задачи
# await task




                                # 8
                                # Как создать задачу и что с ней происходит
# Задачи создают с использованием экземпляра корутины, предоставленного соответствующему механизму.
# вспомним создание корутины-
# async def task_coroutine():
#     # ...
# Задачу можно создать и запланировать на выполнение только внутри корутины.
# Есть два основных способа создания и планирования задач:
# Создать объект Task с использованием высокоуровневого API (предпочтительный способ).
# Создать объект Task с помощью низкоуровневого API.

# высокоуровневыйAPI
# Задачу можно создать, прибегнув к функции asyncio.create_task().
# Эта функция принимает экземпляр класса корутины и необязательное имя задачи,
# а возвращает экземпляр класса asyncio.Task.

# пример-
# coro = task_coroutine()# создание корутины

# task = asyncio.create_task(coro)# создание задачи из корутины
# или в 1 строчку
# task = asyncio.create_task(task_coroutine())

# Когда запускаются задачи?
# На самом деле, задача не будет запущена до тех пор, пока у цикла событий не появится возможность её запустить.
# Это произойдёт тогда, когда все другие корутины перестанут выполняться и настанет очередь интересующей нас задачи.

# Это может произойти в том случае, если вызывающая корутина решит приостановить работу,
# подождать выполнения другой корутины или задачи,
# или решит подождать выполнения новой задачи,
# выполнение которой было только что запланировано.

# Жизненный цикл задачи можно представить себе так:
# Создана (Created).
# Запланирована (Scheduled).
# Выполняется (Running).
# Завершена (Done).
# Обратите внимание на то, что такие пункты нашего списка, как
# «Приостановлена», «Вернула результат», «Выдала исключение» и «Отменена» —
# это, сами по себе, не состояния задачи. Это — важные переходные моменты жизненного цикла выполняющейся задачи.


                            #9
                            #методы у задачи task
# Как проверить состояние задачи
# После того, как объект Task создан — можно проверить состояние задачи.
# В состоянии задачи есть два интересующих нас значения, дающих следующие сведения:
# Завершено ли выполнение задачи.
# Отменено ли выполнение задачи

# Узнать о том, завершено ли выполнение задачи, можно, воспользовавшись её методом done().
# проверка на завершение выполнения задачи
# if task.done(): - вернет True если уже выполнил False во всех остальных
# Выполнение задачи будет завершено если:
# Выполнение корутины завершилось нормально.
# Корутина явным образом вернула результат.
# Корутина выдала неожиданную ошибку или неожиданное исключение.
# Выполнение задачи отменено.

# Проверить то, отменено ли выполнение задачи, можно с помощью её метода
# cancelled().
# if task.cancelled():
# ...
# Задача будет отменена в том случае, если был вызван её метод cancel(),
# и если он был успешно завершён. То есть — если этот метод вернул True.

# Получить результат выполнения задачи можно с помощью метода result().
# value = task.result()
# Этот метод выдаёт возвращаемое значение корутины,
# обёрнутой объектом Task, или None — если корутина не возвращает значение явным образом:
# ! Если результат корутины ошибка - метод result() получит его CancelledError
# пример как обработать
# try:
#     # получение возвращённого значения из обёрнутой корутины
#     value = task.result()
# except asyncio.CancelledError:
#     # задача была отменена

# Для безопасности лучше перед получением задачи проверять не отменена ли она
# пример-
# if not task.cancelled():
#     # получение возвращённого значения из обёрнутой корутины
#     value = task.result()
# else:
#     # задача была отменена

# Если задача ещё не завершила выполнение — при вызове метода result()
# выдаётся исключение InvalidStateError. Оно тоже может нуждаться в обработке:
# пример как его обработать
# try:
#     # получение возвращённого значения из обёрнутой корутины
#     value = task.result()
# except asyncio.InvalidStateError:
#     # выполнение задачи ещё не завершено

# В результате перед получением из задачи значения неплохо будет сначала проверить — завершено ли её выполнение:
# проверка того, завершено ли выполнение задачи
# if not task.done():
#     await task
# получение возвращённого значения из обёрнутой корутины
# value = task.result()


# все искючения внутри задачи можно получить методом exeption()
# exception = task.exception()
# если мы отменили задачу то сработает исключение CancelledEroor
# try:
#     # получение исключения, вызванного задачей
#     exception = task.exception()
# except asyncio.CancelledError:
#     # задача была отменена

# по этому хорошо бы проверять и здесь не является ли задача отмененной
# if not task.cancelled():
#     # получение исключения, вызванного задачей
#     exception = task.exception()
# else:
#     # задача была отменена
# если выполение еще не завершилось то будет исключение InvalidStateError
# Try:
#     # получение исключения, вызванного задачей
#     exception = task.exception()
# except asyncio.InvalidStateError:
#     # выполнение задачи ещё не завершено

# Как отменить выполнение задачи
# отменяет задачу cance()
# Он вернёт True в том случае, если ему удалось отменить задачу, а в противном случае он вернёт False:
# was_cancelled = task.cancel()
# Если выполнение задачи уже завершено — её нельзя отменить.

# Как назначить задаче имя
# создание задачи из корутины
# task = asyncio.create_task(task_coroutine(), name='MyTask')

# Имя задаче можно назначить и с помощью метода set_name():
# назначение задаче имени
# task.set_name('MyTask')

# Узнать имя задачи можно, воспользовавшись методом get_name():
# получение имени задачи
# name = task.get_name()

# Текущие и выполняющиеся задачи
# метод current_task()

"""Пример определение главной корутины"""

# async def main():
#     print('main coroutine started')#     # вывод сообщения
#     task = asyncio.current_task() #     # получение текущей задачи
#     print(task) #     # вывод сведений о ней
# asyncio.run(main()) # # запуск asyncio-программы

# получить все задачи - all_tasks()
# После вызова этой функции в нашем распоряжении будет набор всех задач asyncio-программы.кроме завершенных
# пример, где запускают множество задач, а после этого получают к ним доступ




"""Пример, итог и разбор части 1"""
# async def task_coroutine(value):  # Это корутина - асинхронная функция
#     print(f'task {value} is running')  # Вывод сообщения о запуске задачи
#     await asyncio.sleep(1)  # Имитация долгой операции (1 секунда), без блокировки event loop
# async def main():  # Главная корутина - точка входа в программу
#     print('main coroutine started')  # Сообщение о старте
#
#     # started_tasks = [asyncio.create_task(task_coroutine(i)) for i in range(10)] #или код ниже тоже самое но читаемо
#
#     started_tasks = []  # Список для хранения созданных задач
#
#     for i in range(10):  # Создаём 10 задач
#         coro = task_coroutine(i)  # Создаём корутину (но пока не запускаем)
#         task = asyncio.create_task(coro)  # Оборачиваем корутину в Task и планируем её выполнение
#         # Важно: create_task НЕ означает немедленный старт, задача начнёт выполняться при следующем await
#         started_tasks.append(task)  # Добавляем задачу в список
#
#     # Даём event loop время запустить задачи
#     await asyncio.sleep(0)  # Первый встречающийся await гарантирует что задачи начали выполняться
#
#     # Получаем ВСЕ текущие задачи (включая саму main())
#     tasks = asyncio.all_tasks()  # Возвращает множество всех активных задач
#
#     # Выводим информацию о каждой задаче
#     for task in tasks:
#         # get_name() - имя задачи, get_coro() - обёрнутая корутина
#         print(f'> {task.get_name()}, {task.get_coro()}')
#
#     # Ожидаем завершения только наших 10 задач (а не всех задач в event loop)
#     for task in started_tasks:
#         await task  # Ожидаем завершения каждой задачи
#
#
# # Запускаем asyncio-программу (создаётся event loop, выполняется main())
# asyncio.run(main())
