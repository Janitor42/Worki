import threading
import time

# Синхронизация потоков в Python (threading)

# Когда несколько потоков работают с общими данными,
# возникает состояние гонки (race condition) — непредсказуемый результат из-за конкуренции за ресурсы.
# Чтобы избежать этого, используются механизмы синхронизации.

## для начала приведем пример простой конкуренции Race Condition:



# counter = 0
# def broken_increment():
#     global counter
#     for i in range(10):
#         current = counter# оба потока считывают информация (к примеру counter=7, записывают себе это в переменную current
#         time.sleep(0.000001)  # засыпают на 0.00001 сек (это искусственная задержка но в io задачах она будет реальной)
#         counter = current + 1 #после чего каждый из потоков в нашем случае разморозился а в случае реальный задач взял данные,
#         #и пошел с ними к нашей переменной counter, но поскольку потоков работающих с counter 2 и они работают сначала один в
#         #counter что то положит, потом другой это и есть race condition
#
# # Запускаем два потока
# t1 = threading.Thread(target=broken_increment)
# t2 = threading.Thread(target=broken_increment)
#
# t1.start()
# t2.start()
# t1.join()
# t2.join()
# print(f" Без синхронизации: {counter} (должно быть {2 * 10})")



##далее рассмотрим как решить подобную проблему

                            ##Lock
## Класс Lock для предотвращения состояния гонки
## У экземпляра класса Lock есть два состояния: он может быть заблокирован и разблокирован.

#lock.acquire() захват блокировки
#lock.release() освобождение блокировки
#более безопасным и современным является кон-ция
#with lock:
    #блок кода который работает как захват блокировки как только мы мы уйдем из этой вложенности автоматически применится
    #release
    #удобно тем что мы не забываем сделать release а оно делается автоматом




# lock=threading.Lock() #По умолчанию lock разблокирован — пока вы прямо не укажете обратного.
# counter = 0
# def broken_increment():
#     global counter
#     for i in range(10):
#         lock.acquire()#захват блокировки тем потоком который дошел сюда( программа заблокирована с этой строчки и тот
#         #поток что оказался здесь делат что ему нужно
#
#         current = counter
#         time.sleep(0.000001)
#         counter = current + 1
#
#         lock.release()#освобождение блокировки (другие потоки могут двигаться и входить в lock.acuire
#
# # Запускаем два потока
# t1 = threading.Thread(target=broken_increment)
# t2 = threading.Thread(target=broken_increment)
#
# t1.start()
# t2.start()
# t1.join()
# t2.join()
# print(f" Без синхронизации: {counter} (должно быть {2 * 10})")




# Что нужно запомнить

# 1. Состояние гонки возникает, когда два потока одновременно обращаются к общей переменной.
#
# 2. Для предотвращения состояния гонки можно использовать класс Lock.
#
# 3. Для блокировки объекта класса Lock используйте метод acquire().
#
# 4. Для разблокировки объекта класса Lock используйте метод release().




# Принцип работы (на примере туалета):
# Поток подходит к двери (Lock)
# Если дверь открыта (lock свободен) → поток заходит и запирает дверь (lock.acquire())
# Если дверь заперта (lock занят) → другой поток ждёт у двери (блокируется)
# Поток делает свои дела
# Работает с общими данными (например, изменяет переменную)
# Поток выходит- Отпирает дверь (lock.release()), чтобы другие потоки могли войти


# я правильно понимаю что как только один из потоков прочитал with lock или lock. acuire()
# остальным потокам которые доходят до этой строки необходимо
# ждать пока тот поток который это прочитал не выйдет из блока кода with lock или не прочитает lock.release()
# Да, ты абсолютно правильно понял!
#
# Когда поток вызывает lock.acquire() или входит в with lock:
#
# Он захватывает (блокирует) мьютекс.
#
# Если другой поток уже удерживает этот lock, текущий поток блокируется и ждёт, пока блокировка не освободится.
#
# Когда поток выходит из with lock или вызывает lock.release():
#
# Блокировка освобождается, и один из ожидающих потоков (если есть) получает её и продолжает выполнение.