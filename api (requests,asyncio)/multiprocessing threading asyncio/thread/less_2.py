# если в задаче с 2 for мы посчитаем все время которое понадобилось сначало для последовательного решение
# а затем в 2 потока то мы получим следующих код

import time
# import time
# a=time.time()
# for one in range(1, 11):
#     one * 100_000 ** 345554
#     print('one', one)
# for two in range(1, 11):
#     two * 100_000 ** 345554
#     print('two', two)
# print(round(time.time()-a,2), 'это время я потратил 2 for решал я ее в 1 поток')
# время примерно 10.5

# теперь этот же пример но уже в 2 потока
# import threading
# import time
# a=time.time()
# def go_two():
#     for two in range(1, 11):
#         print(f'two {two} ')
#         two * 100_000 ** 345554
#
# go = threading.Thread(target=go_two)
# go.start()
#
# for one in range(1, 11):
#     print(f'one {one} ')
#     one * 100_000 ** 345554
# print(round(time.time()-a,2), 'это время я потратил 2 for решал я ее в 2 потока')

# что мы видим? время не особо поменялось, может на 1 секунду), но если бы это были паралельные потоки то время бы сокра-
# тилось в 2 раза. Раз этого не произошло значит потоки не паралельны. Как раз здесь у нас сидит GIL
# как это работает (устроено) поток читает строчку, начинает ее делать (она сложная и делается какое то время, в это время
# когда расчет готов gil дергает интерпретатор на другой поток и он идет делать другое, этот же поток останавливается и
# ждет когда интерпертатор прийдет к нему и продолжит работу.
# как именно дергать интерпретатор в потоках решает gil (система)  и в большинстве случаев она нам не нужно туда лезть
# и что либо настраивать, но будут для общей полноты картины мы рассмотрим некоторые известные особенности работы с потоками


# где применяются потоки

# Сетевые запросы (HTTP, API, веб-скрапинг).
# Чтение/запись файлов.
# Работа с базами данных (SQLite, PostgreSQL и др.).

# Параллельное выполнение независимых операций
# Обработка нескольких URL, файлов, запросов одновременно.\

# GUI-приложения
# Фоновые задачи в Tkinter, PyQt (чтобы интерфейс не зависал).
# Серверы и сокеты
# Многопоточные серверы (обработка нескольких клиентов).

# Фоновые процессы
# Логирование, мониторинг, периодические задачи.
# Таймеры и отложенные операции.

# Игры и интерактивные приложения
# ИИ, физика, сетевая синхронизация без блокировки основного потока.

# Ускорение операций с ожиданием
# Когда программа тратит время на ожидание (I/O-bound).


# ниже давайте рассмотрим gui tkinter с потоками и без
# без потока

# import tkinter as tk
# import time
# def long_task():
#     time.sleep(5)  # Имитация долгой операции
#     label.config(text="Готово!")
# root = tk.Tk()
# root.geometry('400x400')
# label = tk.Label(root, text="Ожидание...")
# label.pack()
# # Кнопка, которая запускает долгую операцию (замораживает GUI)
# tk.Button(root, text="Старт", command=long_task,font=('Arial',20),activebackground='red').pack()
# root.mainloop()

# теперь тот же пример но с потоком
# import tkinter as tk
# import threading
# import time
#
# def long_task():
#
#     label.config(text="Готово!")
# def safe_long_task():
#     time.sleep(5)
#     root.after(0, long_task) # метод у tk который запускает фу=цию через кол-во миллисекунд (писание ниже)
# def start_thread():
#     thread = threading.Thread(target=safe_long_task)
#     thread.start()
#
# root = tk.Tk()
# label = tk.Label(root, text="Ожидание...")
# label.pack()
# tk.Button(root, text="Старт", command=start_thread,font=('Arial',20),activebackground='red').pack()
#
# root.mainloop()

#приложение не зависает при нажимании на кнопку, а результат появляется через 5 секунд

# Как работает after()
# Когда вы вызываете after(), Tkinter:
# Добавляет задачу в очередь главного цикла
# Продолжает обрабатывать события интерфейса
# Когда приходит время - выполняет вашу функцию

# Почему after() безопасен для потоков?
# Tkinter не потокобезопасен, но after():
# Помещает задачу в очередь главного потока
# Главный цикл выполняет её, когда освободится
# Исключает конфликты при доступе к виджетам

#метод after идеален для потоков 0

#далее будет рассматривать Race Condition (гонка потоков) и остальные параметры класса Threard

